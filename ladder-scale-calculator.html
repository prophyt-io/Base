<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LadderScale Calculator</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&family=Unbounded:wght@300;600;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #12171f;
            --bg-tertiary: #1a2332;
            --accent-primary: #00ff88;
            --accent-secondary: #00d4ff;
            --accent-danger: #ff3366;
            --accent-warning: #ffd60a;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #4d5761;
            --border: rgba(255, 255, 255, 0.08);
            --glow: rgba(0, 255, 136, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 136, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 212, 255, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .grain {
            position: fixed;
            inset: 0;
            opacity: 0.025;
            pointer-events: none;
            z-index: 1;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            animation: grain 8s steps(10) infinite;
        }

        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -10%); }
            20% { transform: translate(-15%, 5%); }
            30% { transform: translate(7%, -25%); }
            40% { transform: translate(-5%, 25%); }
            50% { transform: translate(-15%, 10%); }
            60% { transform: translate(15%, 0%); }
            70% { transform: translate(0%, 15%); }
            80% { transform: translate(3%, 25%); }
            90% { transform: translate(-10%, 10%); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 60px 40px;
            position: relative;
            z-index: 2;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
            animation: slideDown 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
        }

        h1 {
            font-family: 'Unbounded', sans-serif;
            font-size: clamp(2.5rem, 6vw, 5rem);
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            letter-spacing: -0.02em;
            text-shadow: 0 0 40px var(--glow);
        }

        .subtitle {
            font-size: 0.95rem;
            color: var(--text-secondary);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .main-grid {
            display: grid;
            grid-template-columns: minmax(400px, 500px) 1fr;
            gap: 40px;
            animation: fadeIn 1s cubic-bezier(0.16, 1, 0.3, 1) 0.2s backwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 32px;
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02) 0%, transparent 100%);
            pointer-events: none;
        }

        .panel-header {
            font-family: 'Unbounded', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 28px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .panel-header::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 2px;
        }

        .input-group {
            margin-bottom: 28px;
        }

        label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 14px 18px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
            box-shadow: 0 0 0 3px var(--glow);
        }

        input:hover:not(:focus) {
            border-color: rgba(255, 255, 255, 0.15);
        }

        .slider-container {
            margin-top: 16px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: transparent;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            position: relative;
            z-index: 2;
        }

        .slider-input-wrapper {
            position: relative;
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        .slider-input-wrapper input[type="range"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin: 0;
        }

        .slider-track {
            position: relative;
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            margin-bottom: 4px;
        }

        .slider-track-fill {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 3px;
            transition: left 0.15s ease-out, width 0.15s ease-out;
            z-index: 1;
        }

        .slider-track-fill.at-optimal {
            background: rgba(0, 255, 136, 0.7);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.4);
        }

        .slider-track-ai {
            position: absolute;
            height: 100%;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 3px;
            pointer-events: none;
        }

        .ai-badge {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.65rem;
            color: var(--accent-primary);
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            white-space: nowrap;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(0, 255, 136, 0.2);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 0 6px rgba(0, 255, 136, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 0 4px rgba(0, 255, 136, 0.2);
        }

        .slider-labels {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 8px;
            margin-top: 8px;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .slider-labels span:nth-child(2) {
            text-align: center;
            color: var(--accent-primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            text-align: center;
            transition: all 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--accent-primary);
        }

        .stat-value.secondary {
            color: var(--accent-secondary);
        }

        .stat-value.warning {
            color: var(--accent-warning);
        }

        .chart-container {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 32px;
            height: 500px;
            position: relative;
            overflow: hidden;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            will-change: contents;
        }

        .ladder-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-primary);
            opacity: 0.6;
            will-change: top, opacity;
        }

        .ladder-line:hover {
            opacity: 1;
            height: 3px;
            z-index: 10;
            transition: opacity 0.15s ease, height 0.15s ease;
        }

        .ladder-label {
            position: absolute;
            right: 8px;
            transform: translateY(-50%);
            font-size: 0.7rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            pointer-events: none;
            will-change: top;
        }

        .fib-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            border-top: 2px dashed;
        }

        .fib-line.fib-382 {
            border-color: var(--accent-warning);
        }

        .fib-line.fib-618 {
            border-color: var(--accent-danger);
        }

        .avg-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-secondary);
            opacity: 0.8;
        }

        .chart-axis {
            position: absolute;
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        .y-axis {
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            padding-right: 8px;
        }

        .ladder-table {
            margin-top: 24px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            overflow: hidden;
            max-height: 400px;
            overflow-y: auto;
        }

        .ladder-table::-webkit-scrollbar {
            width: 8px;
        }

        .ladder-table::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .ladder-table::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: var(--bg-secondary);
            padding: 12px 16px;
            text-align: left;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        td {
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            font-size: 0.85rem;
        }

        tr:hover td {
            background: rgba(0, 255, 136, 0.05);
        }

        .highlight {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .action-bar {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .action-btn {
            flex: 1;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .action-btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        .action-btn.success {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* Preset button styles */
        .preset-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .preset-btn {
            flex: 1;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .preset-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .preset-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.3);
        }

        .preset-btn .order-count {
            display: block;
            font-size: 0.65rem;
            opacity: 0.8;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div class="grain"></div>
    <div class="container">
        <header>
            <h1>LadderScale</h1>
            <p class="subtitle">Inverse-Weighted DCA Calculator</p>
        </header>

        <div class="main-grid">
            <!-- Controls Panel -->
            <div class="panel">
                <div class="panel-header">Configuration</div>
                
                <div class="input-group">
                    <label for="symbol">Symbol</label>
                    <input type="text" id="symbol" value="GME" placeholder="Enter ticker symbol">
                </div>

                <div class="input-group">
                    <label for="targetPrices">
                        Target Prices (AI Optimization)
                        <span style="color: var(--accent-secondary); font-size: 0.7rem;">OPTIONAL</span>
                        <span id="optimizationStatus" style="display: none; color: var(--accent-warning); font-size: 0.65rem; margin-left: 8px;">‚è≥ Optimizing...</span>
                    </label>
                    <input type="text" id="targetPrices" placeholder="[22.53, 21.23, 20.1] - Comma or bracket separated"
                           style="font-size: 0.95rem;">
                    <div style="margin-top: 8px; font-size: 0.7rem; color: var(--text-muted);">
                        Grid will optimize to align with these price levels
                    </div>

                    <!-- Preset buttons for order count ranges -->
                    <div class="preset-buttons">
                        <button class="preset-btn" id="presetLow">5-10</button>
                        <button class="preset-btn active" id="presetMedium">10-20</button>
                        <button class="preset-btn" id="presetHigh">20-30</button>
                    </div>
                </div>

                <div class="input-group">
                    <label for="startPrice">Start Price ($)</label>
                    <input type="number" id="startPrice" value="25.38" step="0.01" placeholder="Current market price">
                </div>

                <div class="input-group">
                    <label for="capital">Capital ($)</label>
                    <input type="number" id="capital" value="7500" step="100" placeholder="Total capital to deploy">
                </div>

                <div class="input-group">
                    <label for="levels">Levels (<span id="levelsValue">15</span>)</label>
                    <div class="slider-container">
                        <div class="slider-track">
                            <div class="slider-track-ai" style="left: 40%; width: 40%;" id="levelsAiZone">
                                <div class="ai-badge">AI Assisted</div>
                            </div>
                        </div>
                        <div class="slider-input-wrapper">
                            <div class="slider-track-fill" id="levelsFill"></div>
                            <input type="range" id="levels" min="5" max="30" value="15" step="1">
                        </div>
                        <div class="slider-labels">
                            <span>5</span>
                            <span id="levelsAiLabel">10-20 (AI)</span>
                            <span>30</span>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label for="alpha">Alpha - Aggressiveness (<span id="alphaValue">1.61</span>)</label>
                    <div class="slider-container">
                        <div class="slider-track">
                            <div class="slider-track-ai" style="left: 43%; width: 20%;" id="alphaAiZone">
                                <div class="ai-badge">AI Assisted</div>
                            </div>
                        </div>
                        <div class="slider-input-wrapper">
                            <div class="slider-track-fill" id="alphaFill"></div>
                            <input type="range" id="alpha" min="-0.30" max="3.0" value="1.61" step="0.01">
                        </div>
                        <div class="slider-labels">
                            <span>-0.30</span>
                            <span id="alphaAiLabel">1.3-2.0 (AI)</span>
                            <span>3.0</span>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label for="offset">Start Price Offset (<span id="offsetValue">0.00</span>%)</label>
                    <div class="slider-container">
                        <div class="slider-track">
                            <div class="slider-track-ai" style="left: 50%; width: 2%;" id="offsetAiZone">
                                <div class="ai-badge" style="font-size: 0.55rem;">AI</div>
                            </div>
                        </div>
                        <div class="slider-input-wrapper">
                            <div class="slider-track-fill" id="offsetFill"></div>
                            <input type="range" id="offset" min="-1.0" max="1.0" value="0" step="0.01">
                        </div>
                        <div class="slider-labels">
                            <span>-1%</span>
                            <span id="offsetAiLabel">0% (AI)</span>
                            <span>+1%</span>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label for="spacing">Grid Spacing Factor (<span id="spacingValue">1.00</span>)</label>
                    <div class="slider-container">
                        <div class="slider-track">
                            <div class="slider-track-ai" style="left: 33%; width: 34%;" id="spacingAiZone">
                                <div class="ai-badge">AI Assisted</div>
                            </div>
                        </div>
                        <div class="slider-input-wrapper">
                            <div class="slider-track-fill" id="spacingFill"></div>
                            <input type="range" id="spacing" min="0.5" max="2.0" value="1.0" step="0.01">
                        </div>
                        <div class="slider-labels">
                            <span>0.5 (Tighter)</span>
                            <span id="spacingAiLabel">1.0 (Equal)</span>
                            <span>2.0 (Wider)</span>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label for="bottom">Bottom Price ($)</label>
                    <input type="number" id="bottom" value="17.86" step="0.01" placeholder="Mean - 3œÉ">
                </div>
            </div>

            <!-- Visualization Panel -->
            <div class="panel">
                <div class="panel-header">Visualization</div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Avg Entry</div>
                        <div class="stat-value" id="avgEntry">--</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Total Shares</div>
                        <div class="stat-value secondary" id="totalShares">--</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Fib 38.2%</div>
                        <div class="stat-value warning" id="fib382">--</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Fib 61.8%</div>
                        <div class="stat-value warning" id="fib618">--</div>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-canvas" id="chartCanvas">
                        <div class="empty-state">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"></path>
                            </svg>
                            <div>Configure parameters to visualize ladder</div>
                        </div>
                    </div>
                </div>

                <div class="ladder-table" id="ladderTableContainer" style="display: none;">
                    <table>
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Price</th>
                                <th>Shares</th>
                                <th>Allocation</th>
                                <th>Weight %</th>
                            </tr>
                        </thead>
                        <tbody id="ladderTableBody"></tbody>
                    </table>
                </div>

                <div class="action-bar">
                    <button class="action-btn" onclick="exportCSV()">‚¨á Export CSV</button>
                    <button class="action-btn" onclick="copyOrders()">üìã Copy Orders</button>
                    <button class="action-btn" onclick="shareURL()">üîó Share URL</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentLadderData = null;
        let cachedOptimizationResult = null;
        let lastTargetPrices = '';
        let rafId = null; // requestAnimationFrame ID for smooth updates
        let optimizationTimeoutId = null; // Track optimization setTimeout for cancellation
        let isCalculating = false; // Mutex to prevent race conditions

        // Multi-preset state management
        let currentPreset = '10-20'; // Default to medium preset
        let presetResults = {
            '5-10': null,
            '10-20': null,
            '20-30': null
        };
        let lastBottomPrice = null; // Track bottom price to invalidate cache when it changes
        let lastStartPrice = null; // Track start price to invalidate cache when it changes

        // Store optimal values for snap-to functionality
        let optimalValues = {
            alpha: null,
            levels: null,
            offset: null,
            spacing: null
        };

        // Flag to prevent double calculation during programmatic slider movement
        let isMovingSliders = false;

        // Utility functions
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        function roundFinancial(value) {
            return Math.round(value * 100) / 100;
        }

        // Update slider displays immediately with requestAnimationFrame for smooth 60fps
        function scheduleUpdate() {
            // Skip if sliders are being moved programmatically (preset switch)
            if (isMovingSliders) {
                return;
            }
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
            }
            rafId = requestAnimationFrame(() => {
                calculateLadder();
                rafId = null;
            });
        }

        // Snap slider to optimal value if within range (stronger magnet)
        function snapToOptimal(slider, sliderType, step) {
            const optimalValue = optimalValues[sliderType];
            if (optimalValue === null) return;

            const currentValue = parseFloat(slider.value);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);

            // Calculate snap threshold as percentage of slider range (stronger magnet)
            const range = max - min;
            const snapThreshold = range * 0.08; // 8% of range = stronger magnet

            const diff = Math.abs(currentValue - optimalValue);

            if (diff <= snapThreshold) {
                // Snap to optimal value
                slider.value = optimalValue;

                // Visual feedback - flash the slider
                slider.style.transition = 'box-shadow 0.2s';
                slider.style.boxShadow = '0 0 20px rgba(0, 255, 136, 0.6)';
                setTimeout(() => {
                    slider.style.boxShadow = '';
                }, 300);

                return true; // Snapped
            }
            return false; // Did not snap
        }

        document.getElementById('levels').addEventListener('input', (e) => {
            document.getElementById('levelsValue').textContent = e.target.value;
            updateSliderBackground(e.target, 'levels');

            // Try to snap to optimal
            if (snapToOptimal(e.target, 'levels', 1)) {
                document.getElementById('levelsValue').textContent = e.target.value;
            }

            scheduleUpdate();
        });

        document.getElementById('alpha').addEventListener('input', (e) => {
            document.getElementById('alphaValue').textContent = parseFloat(e.target.value).toFixed(2);
            updateSliderBackground(e.target, 'alpha');

            // Try to snap to optimal
            if (snapToOptimal(e.target, 'alpha', 0.01)) {
                document.getElementById('alphaValue').textContent = parseFloat(e.target.value).toFixed(2);
            }

            scheduleUpdate();
        });

        document.getElementById('offset').addEventListener('input', (e) => {
            document.getElementById('offsetValue').textContent = parseFloat(e.target.value).toFixed(2);
            updateSliderBackground(e.target, 'offset');

            // Try to snap to optimal
            if (snapToOptimal(e.target, 'offset', 0.01)) {
                document.getElementById('offsetValue').textContent = parseFloat(e.target.value).toFixed(2);
            }

            scheduleUpdate();
        });

        document.getElementById('spacing').addEventListener('input', (e) => {
            document.getElementById('spacingValue').textContent = parseFloat(e.target.value).toFixed(2);
            updateSliderBackground(e.target, 'spacing');

            // Try to snap to optimal
            if (snapToOptimal(e.target, 'spacing', 0.01)) {
                document.getElementById('spacingValue').textContent = parseFloat(e.target.value).toFixed(2);
            }

            scheduleUpdate();
        });

        // Debounce function to prevent excessive calculations during typing
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Debounced calculation for target prices (prevents lock-up and runs optimization)
        const debouncedCalculateWithOptimization = debounce(() => calculateLadder(true), 800);

        // All inputs trigger immediate recalculation
        document.getElementById('symbol').addEventListener('input', calculateLadder);
        document.getElementById('targetPrices').addEventListener('input', debouncedCalculateWithOptimization); // Debounced with optimization
        document.getElementById('startPrice').addEventListener('input', calculateLadder);
        document.getElementById('capital').addEventListener('input', calculateLadder);
        document.getElementById('bottom').addEventListener('input', calculateLadder);

        // Preset button click handlers
        document.getElementById('presetLow').addEventListener('click', () => switchPreset('5-10'));
        document.getElementById('presetMedium').addEventListener('click', () => switchPreset('10-20'));
        document.getElementById('presetHigh').addEventListener('click', () => switchPreset('20-30'));

        // Style the range sliders - anchored to AI optimal value when available
        // Uses separate fill elements for smooth CSS transitions
        function updateSliderBackground(slider, sliderType = null) {
            const value = parseFloat(slider.value);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const currentPercent = ((value - min) / (max - min)) * 100;

            // Get the fill element for this slider
            const fillId = slider.id + 'Fill';
            const fillEl = document.getElementById(fillId);

            if (!fillEl) {
                // Fallback: set background on slider itself if no fill element
                slider.style.background = `linear-gradient(90deg, var(--accent-primary), var(--accent-secondary) ${currentPercent}%, var(--bg-tertiary) ${currentPercent}%)`;
                return;
            }

            // Get optimal value for this slider type
            const optimalValue = sliderType ? optimalValues[sliderType] : null;

            if (optimalValue === null) {
                // No AI optimization: Traditional left-to-right fill
                fillEl.style.left = '0%';
                fillEl.style.width = currentPercent + '%';
                fillEl.classList.remove('at-optimal');
                return;
            }

            // Calculate optimal position percentage
            const optimalPercent = ((optimalValue - min) / (max - min)) * 100;

            // Calculate deviation from optimal
            const deviation = value - optimalValue;
            const absDeviation = Math.abs(deviation);
            const rangeSize = max - min;

            // Threshold for "at optimal" (within 1% of range)
            const atOptimalThreshold = rangeSize * 0.01;

            if (absDeviation < atOptimalThreshold) {
                // AT OPTIMAL: Show small centered glow
                fillEl.style.left = Math.max(0, optimalPercent - 4) + '%';
                fillEl.style.width = '8%';
                fillEl.classList.add('at-optimal');
            } else {
                // AWAY FROM OPTIMAL: Fill the gap between optimal and current
                const fillStart = Math.min(currentPercent, optimalPercent);
                const fillEnd = Math.max(currentPercent, optimalPercent);

                fillEl.style.left = fillStart + '%';
                fillEl.style.width = (fillEnd - fillStart) + '%';
                fillEl.classList.remove('at-optimal');
            }
        }

        // Parse target prices from input
        function parseTargetPrices(input) {
            if (!input || input.trim() === '') return null;
            
            // Remove brackets and split by comma
            const cleaned = input.replace(/[\[\]]/g, '').trim();
            const prices = cleaned.split(',')
                .map(p => parseFloat(p.trim()))
                .filter(p => !isNaN(p) && p > 0);
            
            return prices.length > 0 ? prices.sort((a, b) => b - a) : null; // Sort descending
        }

        // Optimize grid alignment to target prices with exact matching
        function optimizeGridAlignment(startPrice, bottom, targetPrices, levelRangeConstraint = null) {
            if (!targetPrices || targetPrices.length === 0) {
                return null;
            }

            let bestScore = -Infinity;
            let bestLevels = 15;
            let bestOffset = 0;
            let bestSpacing = 1.0;
            let bestExactMatches = 0;  // Track exact matches at function scope

            // Determine level range based on preset constraint
            const minLevel = levelRangeConstraint ? levelRangeConstraint.min : 5;
            const maxLevel = levelRangeConstraint ? levelRangeConstraint.max : 30;

            // Level range - step by 1 for precision within preset
            const levelRange = [];
            for (let l = minLevel; l <= maxLevel; l += 1) {
                levelRange.push(l);
            }

            // Offset range: -1% to +1% with FINER step (0.05% instead of 0.25%)
            const offsetRange = [];
            for (let o = -1.0; o <= 1.0; o += 0.05) {
                offsetRange.push(o);
            }

            // Spacing range: 0.5 to 2.0 with FINER step (0.05 instead of 0.25)
            const spacingRange = [];
            for (let s = 0.5; s <= 2.0; s += 0.05) {
                spacingRange.push(s);
            }

            const epsilon = 0.1;

            // Grid search - NO bottom adjustment (keep user's bottom fixed)
            for (const testLevels of levelRange) {
                for (const testOffset of offsetRange) {
                    for (const testSpacing of spacingRange) {
                        // Apply offset to start price
                        const adjustedStart = startPrice * (1 + testOffset / 100);

                        if (bottom >= adjustedStart || bottom <= 0) continue;

                        // Generate ladder with progressive spacing
                        const priceLevels = generateProgressiveLadder(
                            adjustedStart,
                            bottom,  // User's bottom - NO adjustment
                            testLevels,
                            testSpacing
                        );

                        // Calculate exact match score (tracking unique targets matched)
                        let exactMatches = 0;
                        let closeMatches = 0;
                        let proximityScore = 0;
                        const matchedTargets = new Set(); // Track which targets have been matched

                        for (const target of targetPrices) {
                            let bestMatch = Infinity;
                            let targetMatched = false;

                            for (const level of priceLevels) {
                                const diff = Math.abs(level - target);
                                const percentDiff = diff / target;

                                // Exact match within 0.1% - HIGHEST PRIORITY (only count once per target)
                                if (percentDiff < 0.001 && !targetMatched) {
                                    exactMatches += 1000;
                                    matchedTargets.add(target); // Mark this target as matched
                                    targetMatched = true;
                                }
                                // Close match within 0.5% (only if not already exact matched)
                                else if (percentDiff < 0.005 && !targetMatched && !matchedTargets.has(target)) {
                                    closeMatches += 100;
                                }
                                // Reasonable match within 1% (only if not already matched)
                                else if (percentDiff < 0.01 && !targetMatched && !matchedTargets.has(target)) {
                                    closeMatches += 10;
                                }

                                if (diff < bestMatch) {
                                    bestMatch = diff;
                                }
                            }

                            proximityScore += 1 / (1 + bestMatch);
                        }

                        // Score: exact matches heavily prioritized
                        const score = exactMatches + closeMatches + proximityScore;

                        if (score > bestScore) {
                            bestScore = score;
                            bestLevels = testLevels;
                            bestOffset = testOffset;
                            bestSpacing = testSpacing;
                            bestExactMatches = exactMatches;  // Save the exact match count
                        }
                    }
                }
            }

            return {
                optimalLevels: bestLevels,
                optimalOffset: roundFinancial(bestOffset),
                optimalSpacing: roundFinancial(bestSpacing),
                score: bestScore,
                exactMatchCount: Math.round(bestExactMatches / 1000),  // Number of exact matches
                message: `Optimized: Levels=${bestLevels}, Offset=${bestOffset.toFixed(2)}%, Spacing=${bestSpacing.toFixed(2)}, Score=${bestScore.toFixed(1)}, Exact Matches=${Math.round(bestExactMatches / 1000)}`
            };
        }

        // Cancel any pending optimization to prevent stale calculations
        function cancelPendingOptimization() {
            if (optimizationTimeoutId !== null) {
                clearTimeout(optimizationTimeoutId);
                optimizationTimeoutId = null;
            }
        }

        // Generate ladder with progressive spacing (spacing factor controls how gaps widen/narrow)
        function generateProgressiveLadder(startPrice, bottom, levels, spacingFactor) {
            // Guard against invalid levels count - prevents division by zero
            if (levels < 2) {
                console.warn('generateProgressiveLadder: levels must be >= 2, got', levels);
                levels = 2;
            }

            const priceLevels = [];
            const totalRange = startPrice - bottom;

            if (spacingFactor === 1.0) {
                // Equal spacing (linear)
                const step = totalRange / (levels - 1);
                for (let i = 0; i < levels; i++) {
                    priceLevels.push(roundFinancial(startPrice - (step * i)));
                }
            } else {
                // Progressive spacing (exponential or logarithmic)
                // spacingFactor > 1.0 = wider gaps as we descend (exponential)
                // spacingFactor < 1.0 = tighter gaps as we descend (logarithmic)
                
                let cumulativeDistance = 0;
                let totalWeight = 0;
                
                // Calculate total weight for normalization
                for (let i = 0; i < levels; i++) {
                    totalWeight += Math.pow(i + 1, spacingFactor);
                }
                
                priceLevels.push(startPrice);
                
                for (let i = 1; i < levels; i++) {
                    const weight = Math.pow(i, spacingFactor);
                    cumulativeDistance += weight;
                    const normalizedDistance = (cumulativeDistance / totalWeight) * totalRange;
                    priceLevels.push(roundFinancial(startPrice - normalizedDistance));
                }
            }
            
            return priceLevels;
        }

        // Optimize alpha to place weighted average entry below Fibonacci 61.8% level
        function optimizeAlphaForFibonacci(startPrice, bottom, levels, spacing, offset, capital) {
            const epsilon = 0.1;
            const adjustedStart = startPrice * (1 + offset / 100);
            const fib618 = bottom + 0.618 * (adjustedStart - bottom);
            const targetBelowFib = fib618 * 0.99; // Target: 1% below Fib 61.8%

            let bestAlpha = 1.61;
            let bestDiff = Infinity;

            // Search alpha range: -0.30 to 3.0 (step 0.02 for precision)
            for (let alpha = -0.30; alpha <= 3.0; alpha += 0.02) {
                // Generate ladder with current parameters
                const priceLevels = generateProgressiveLadder(adjustedStart, bottom, levels, spacing);

                // Calculate weights with current alpha
                const weights = priceLevels.map(p => 1 / Math.pow((p - bottom + epsilon), alpha));
                const sumWeights = weights.reduce((a, b) => a + b, 0);
                const normWeights = weights.map(w => w / sumWeights);

                // Allocate capital
                const allocations = normWeights.map(w => roundFinancial(w * capital));
                const shares = allocations.map((a, i) => Math.floor(a / priceLevels[i]));

                // Calculate weighted average entry
                const totalShares = shares.reduce((a, b) => a + b, 0);
                const totalAllocated = shares.reduce((sum, s, i) => sum + roundFinancial(s * priceLevels[i]), 0);
                const avgEntry = totalShares > 0 ? roundFinancial(totalAllocated / totalShares) : 0;

                // Calculate difference from target (1% below Fib 61.8%)
                const diffFromTarget = Math.abs(avgEntry - targetBelowFib);

                // Minimize difference from target
                if (diffFromTarget < bestDiff) {
                    bestDiff = diffFromTarget;
                    bestAlpha = alpha;
                }
            }

            return {
                optimalAlpha: roundFinancial(bestAlpha),
                targetAvgEntry: roundFinancial(targetBelowFib),
                fib618Level: roundFinancial(fib618),
                message: `Alpha AI: Œ±=${bestAlpha.toFixed(2)} targets avg entry below Fib 61.8%`
            };
        }

        // Update AI-assisted zones dynamically based on optimization
        function updateAiZones(optimalAlpha, optimalLevels, optimalOffset, optimalSpacing, hasTargets) {
            const alphaSlider = document.getElementById('alpha');
            const levelsSlider = document.getElementById('levels');
            const offsetSlider = document.getElementById('offset');
            const spacingSlider = document.getElementById('spacing');
            
            const alphaMin = parseFloat(alphaSlider.min);
            const alphaMax = parseFloat(alphaSlider.max);
            const levelsMin = parseFloat(levelsSlider.min);
            const levelsMax = parseFloat(levelsSlider.max);
            const offsetMin = parseFloat(offsetSlider.min);
            const offsetMax = parseFloat(offsetSlider.max);
            const spacingMin = parseFloat(spacingSlider.min);
            const spacingMax = parseFloat(spacingSlider.max);

            if (hasTargets && optimalAlpha !== null && optimalLevels !== null) {
                // Store optimal values for snap-to functionality
                optimalValues.alpha = optimalAlpha;
                optimalValues.levels = optimalLevels;
                optimalValues.offset = optimalOffset;
                optimalValues.spacing = optimalSpacing;

                // Alpha zone
                const alphaZoneMin = Math.max(alphaMin, optimalAlpha - 0.15);
                const alphaZoneMax = Math.min(alphaMax, optimalAlpha + 0.15);
                const alphaLeftPercent = ((alphaZoneMin - alphaMin) / (alphaMax - alphaMin)) * 100;
                const alphaWidth = ((alphaZoneMax - alphaZoneMin) / (alphaMax - alphaMin)) * 100;
                
                const alphaAiZone = document.getElementById('alphaAiZone');
                const alphaAiLabel = document.getElementById('alphaAiLabel');
                alphaAiZone.style.left = `${alphaLeftPercent}%`;
                alphaAiZone.style.width = `${alphaWidth}%`;
                alphaAiLabel.textContent = `${alphaZoneMin.toFixed(2)}-${alphaZoneMax.toFixed(2)} (AI)`;
                
                // Levels zone
                const levelsZoneMin = Math.max(levelsMin, optimalLevels - 2);
                const levelsZoneMax = Math.min(levelsMax, optimalLevels + 2);
                const levelsLeftPercent = ((levelsZoneMin - levelsMin) / (levelsMax - levelsMin)) * 100;
                const levelsWidth = ((levelsZoneMax - levelsZoneMin) / (levelsMax - levelsMin)) * 100;
                
                const levelsAiZone = document.getElementById('levelsAiZone');
                const levelsAiLabel = document.getElementById('levelsAiLabel');
                levelsAiZone.style.left = `${levelsLeftPercent}%`;
                levelsAiZone.style.width = `${levelsWidth}%`;
                levelsAiLabel.textContent = `${Math.round(levelsZoneMin)}-${Math.round(levelsZoneMax)} (AI)`;
                
                // Offset zone (narrow zone around optimal)
                const offsetZoneMin = Math.max(offsetMin, optimalOffset - 0.1);
                const offsetZoneMax = Math.min(offsetMax, optimalOffset + 0.1);
                const offsetLeftPercent = ((offsetZoneMin - offsetMin) / (offsetMax - offsetMin)) * 100;
                const offsetWidth = Math.max(2, ((offsetZoneMax - offsetZoneMin) / (offsetMax - offsetMin)) * 100);
                
                const offsetAiZone = document.getElementById('offsetAiZone');
                const offsetAiLabel = document.getElementById('offsetAiLabel');
                offsetAiZone.style.left = `${offsetLeftPercent}%`;
                offsetAiZone.style.width = `${offsetWidth}%`;
                offsetAiLabel.textContent = `${optimalOffset.toFixed(2)}% (AI)`;
                
                // Spacing zone
                const spacingZoneMin = Math.max(spacingMin, optimalSpacing - 0.15);
                const spacingZoneMax = Math.min(spacingMax, optimalSpacing + 0.15);
                const spacingLeftPercent = ((spacingZoneMin - spacingMin) / (spacingMax - spacingMin)) * 100;
                const spacingWidth = ((spacingZoneMax - spacingZoneMin) / (spacingMax - spacingMin)) * 100;
                
                const spacingAiZone = document.getElementById('spacingAiZone');
                const spacingAiLabel = document.getElementById('spacingAiLabel');
                spacingAiZone.style.left = `${spacingLeftPercent}%`;
                spacingAiZone.style.width = `${spacingWidth}%`;
                spacingAiLabel.textContent = `${spacingZoneMin.toFixed(2)}-${spacingZoneMax.toFixed(2)} (AI)`;
                
                // Add snap indicators
                addSnapIndicators(alphaSlider, optimalAlpha);
                addSnapIndicators(levelsSlider, optimalLevels);
                addSnapIndicators(offsetSlider, optimalOffset);
                addSnapIndicators(spacingSlider, optimalSpacing);
                
            } else {
                // Reset optimal values
                optimalValues.alpha = null;
                optimalValues.levels = null;
                optimalValues.offset = null;
                optimalValues.spacing = null;

                // Reset to default zones
                const alphaAiZone = document.getElementById('alphaAiZone');
                const alphaAiLabel = document.getElementById('alphaAiLabel');
                alphaAiZone.style.left = '43%';
                alphaAiZone.style.width = '20%';
                alphaAiLabel.textContent = '1.3-2.0 (AI)';
                
                const levelsAiZone = document.getElementById('levelsAiZone');
                const levelsAiLabel = document.getElementById('levelsAiLabel');
                levelsAiZone.style.left = '40%';
                levelsAiZone.style.width = '40%';
                levelsAiLabel.textContent = '10-20 (AI)';
                
                const offsetAiZone = document.getElementById('offsetAiZone');
                const offsetAiLabel = document.getElementById('offsetAiLabel');
                offsetAiZone.style.left = '50%';
                offsetAiZone.style.width = '2%';
                offsetAiLabel.textContent = '0% (AI)';
                
                const spacingAiZone = document.getElementById('spacingAiZone');
                const spacingAiLabel = document.getElementById('spacingAiLabel');
                spacingAiZone.style.left = '33%';
                spacingAiZone.style.width = '34%';
                spacingAiLabel.textContent = '1.0 (Equal)';
            }
        }

        // Add visual snap indicators for optimal values
        function addSnapIndicators(slider, optimalValue) {
            // Remove existing indicators
            const container = slider.parentElement;
            const existing = container.querySelectorAll('.snap-indicator');
            existing.forEach(el => el.remove());
            
            if (optimalValue === null) return;
            
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const position = ((optimalValue - min) / (max - min)) * 100;
            
            const indicator = document.createElement('div');
            indicator.className = 'snap-indicator';
            indicator.style.position = 'absolute';
            indicator.style.left = `${position}%`;
            indicator.style.top = '0';
            indicator.style.width = '3px';
            indicator.style.height = '6px';
            indicator.style.background = 'var(--accent-warning)';
            indicator.style.borderRadius = '2px';
            indicator.style.transform = 'translateX(-50%)';
            indicator.style.pointerEvents = 'none';
            indicator.style.zIndex = '10';
            indicator.style.boxShadow = '0 0 4px var(--accent-warning)';
            
            const track = container.querySelector('.slider-track');
            if (track) {
                track.appendChild(indicator);
            }
        }

        // Update preset button labels with order counts and active state
        function updatePresetButtons() {
            const presets = ['5-10', '10-20', '20-30'];
            const buttons = {
                '5-10': document.getElementById('presetLow'),
                '10-20': document.getElementById('presetMedium'),
                '20-30': document.getElementById('presetHigh')
            };

            presets.forEach(preset => {
                const result = presetResults[preset];
                const btn = buttons[preset];

                if (result) {
                    const orderCount = result.optimalLevels;
                    btn.innerHTML = `
                        ${preset}
                        <span class="order-count">(${orderCount} orders)</span>
                    `;
                } else {
                    btn.innerHTML = preset;
                }

                // Update active state
                if (preset === currentPreset) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // Move sliders to optimal values with animation
        function moveSlidersToOptimal(optimalAlpha, optimalLevels, optimalOffset, optimalSpacing) {
            // Set flag to prevent double calculation from slider event handlers
            isMovingSliders = true;

            try {
                const alphaSlider = document.getElementById('alpha');
                const levelsSlider = document.getElementById('levels');
                const offsetSlider = document.getElementById('offset');
                const spacingSlider = document.getElementById('spacing');

                // Move sliders to optimal values
                if (optimalAlpha !== null) {
                    alphaSlider.value = optimalAlpha;
                    document.getElementById('alphaValue').textContent = parseFloat(optimalAlpha).toFixed(2);
                    updateSliderBackground(alphaSlider, 'alpha');
                }

                if (optimalLevels !== null) {
                    levelsSlider.value = optimalLevels;
                    document.getElementById('levelsValue').textContent = optimalLevels;
                    updateSliderBackground(levelsSlider, 'levels');
                }

                if (optimalOffset !== null) {
                    offsetSlider.value = optimalOffset;
                    document.getElementById('offsetValue').textContent = parseFloat(optimalOffset).toFixed(2);
                    updateSliderBackground(offsetSlider, 'offset');
                }

                if (optimalSpacing !== null) {
                    spacingSlider.value = optimalSpacing;
                    document.getElementById('spacingValue').textContent = parseFloat(optimalSpacing).toFixed(2);
                    updateSliderBackground(spacingSlider, 'spacing');
                }
            } finally {
                // Reset flag and trigger a single calculation after event handlers complete
                setTimeout(() => {
                    isMovingSliders = false;
                    // Trigger calculation after sliders are done moving
                    calculateLadder(false);
                }, 0);
            }
        }

        // Switch between presets and update AI zones
        function switchPreset(presetName) {
            currentPreset = presetName;
            const result = presetResults[presetName];

            if (result) {
                // Recalculate alpha for this preset if not already calculated
                if (!result.optimalAlpha) {
                    const baseStartPrice = parseFloat(document.getElementById('startPrice').value);
                    const bottom = parseFloat(document.getElementById('bottom').value);
                    const capital = parseFloat(document.getElementById('capital').value);

                    const alphaResult = optimizeAlphaForFibonacci(
                        baseStartPrice,
                        bottom,
                        result.optimalLevels,
                        result.optimalSpacing,
                        result.optimalOffset,
                        capital
                    );

                    result.optimalAlpha = alphaResult.optimalAlpha;
                }

                // Update AI zones for this preset
                updateAiZones(
                    result.optimalAlpha,
                    result.optimalLevels,
                    result.optimalOffset,
                    result.optimalSpacing,
                    true
                );

                // Update button states
                updatePresetButtons();

                // Move sliders to optimal values for this preset
                // This will trigger slider event handlers which call scheduleUpdate -> calculateLadder
                moveSlidersToOptimal(
                    result.optimalAlpha,
                    result.optimalLevels,
                    result.optimalOffset,
                    result.optimalSpacing
                );

                // Note: Removed explicit calculateLadder(false) call here to prevent double calculation
                // The slider event handlers triggered by moveSlidersToOptimal will handle the calculation
            }
        }

        function calculateLadder(forceOptimization = false) {
            // Skip if already calculating or if sliders are being moved programmatically
            if (isCalculating) {
                return;
            }

            // Cancel any pending optimization to prevent stale calculations
            cancelPendingOptimization();

            const symbol = document.getElementById('symbol').value.trim().toUpperCase();
            const baseStartPrice = parseFloat(document.getElementById('startPrice').value);
            const capital = parseFloat(document.getElementById('capital').value);
            let levels = parseInt(document.getElementById('levels').value);
            let alpha = parseFloat(document.getElementById('alpha').value);
            let bottom = parseFloat(document.getElementById('bottom').value);
            const offset = parseFloat(document.getElementById('offset').value);
            const spacing = parseFloat(document.getElementById('spacing').value);
            const epsilon = 0.1;

            // Apply offset to start price
            const startPrice = baseStartPrice * (1 + offset / 100);

            // Parse target prices
            const targetPricesInput = document.getElementById('targetPrices').value;
            const targetPrices = parseTargetPrices(targetPricesInput);

            // Basic validation with user feedback
            if (!symbol || isNaN(baseStartPrice) || isNaN(capital) || isNaN(bottom) ||
                baseStartPrice <= 0 || capital <= 0 || bottom <= 0 || bottom >= startPrice) {
                console.warn('Validation failed: Check that all prices are positive and bottom < start price');
                return;
            }

            // Validate alpha bounds to prevent numerical overflow
            if (alpha < -0.30 || alpha > 3.0) {
                console.warn('Alpha out of bounds, clamping to [-0.30, 3.0]');
                alpha = Math.max(-0.30, Math.min(3.0, alpha));
            }

            // Validate levels to prevent division by zero
            if (levels < 2) {
                console.warn('Levels must be >= 2, clamping');
                levels = 2;
            }

            // Check if target prices, bottom price, or start price have changed
            const targetPricesChanged = targetPricesInput !== lastTargetPrices;
            const bottomPriceChanged = bottom !== lastBottomPrice;
            const startPriceChanged = baseStartPrice !== lastStartPrice;
            lastTargetPrices = targetPricesInput;
            lastBottomPrice = bottom;
            lastStartPrice = baseStartPrice;

            // If target prices provided and (targets changed OR bottom changed OR start price changed OR forced), run optimization
            if ((targetPrices && targetPrices.length > 0) && (targetPricesChanged || bottomPriceChanged || startPriceChanged || forceOptimization)) {
                // Set mutex BEFORE scheduling to prevent race conditions
                isCalculating = true;

                // Show loading indicator
                const statusEl = document.getElementById('optimizationStatus');
                if (statusEl) {
                    statusEl.style.display = 'inline';
                }

                // Track the timeout ID for cancellation
                optimizationTimeoutId = setTimeout(() => {
                    try {
                        // Run optimization for all 3 presets
                        const presetRanges = {
                            '5-10': {min: 5, max: 10},
                            '10-20': {min: 10, max: 20},
                            '20-30': {min: 20, max: 30}
                        };

                        for (const [presetName, range] of Object.entries(presetRanges)) {
                            const result = optimizeGridAlignment(baseStartPrice, bottom, targetPrices, range);
                            presetResults[presetName] = result;
                        }

                        // Calculate alpha for current preset
                        const currentResult = presetResults[currentPreset];
                        if (currentResult) {
                            const alphaResult = optimizeAlphaForFibonacci(
                                baseStartPrice,
                                bottom,  // Use user's bottom directly, not adjusted
                                currentResult.optimalLevels,
                                currentResult.optimalSpacing,
                                currentResult.optimalOffset,
                                capital
                            );

                            // Store alpha result with preset result
                            currentResult.optimalAlpha = alphaResult.optimalAlpha;

                            // Update AI zones for current preset
                            updateAiZones(
                                currentResult.optimalAlpha,
                                currentResult.optimalLevels,
                                currentResult.optimalOffset,
                                currentResult.optimalSpacing,
                                true
                            );

                            console.log('Grid Optimization:', currentResult.message);
                            console.log('Alpha Optimization:', alphaResult.message);
                        }

                        // Update preset button labels with order counts
                        updatePresetButtons();

                        // Move sliders to optimal values for current preset
                        moveSlidersToOptimal(
                            currentResult.optimalAlpha,
                            currentResult.optimalLevels,
                            currentResult.optimalOffset,
                            currentResult.optimalSpacing
                        );

                        // Continue with rest of calculation
                        completeCalculation(symbol, startPrice, baseStartPrice, capital, levels, alpha, bottom, offset, spacing, targetPrices, currentResult);
                    } finally {
                        // Hide loading indicator
                        if (statusEl) {
                            statusEl.style.display = 'none';
                        }
                        isCalculating = false;
                        optimizationTimeoutId = null;
                    }
                }, 10);
                return; // Exit early, will continue in setTimeout
            } else if (!targetPrices || targetPrices.length === 0) {
                // Reset when no targets
                Object.keys(presetResults).forEach(key => presetResults[key] = null);
                cachedOptimizationResult = null;
                lastBottomPrice = null; // Reset bottom price tracker
                lastStartPrice = null; // Reset start price tracker
                updateAiZones(null, null, null, null, false);
                updatePresetButtons();
            }

            // Complete calculation without re-running optimization (fast path for sliders)
            // Use current preset result if available, otherwise fall back to cached
            const resultToUse = (targetPrices && targetPrices.length > 0) ? presetResults[currentPreset] : cachedOptimizationResult;
            completeCalculation(symbol, startPrice, baseStartPrice, capital, levels, alpha, bottom, offset, spacing, targetPrices, resultToUse);
        }

        function completeCalculation(symbol, startPrice, baseStartPrice, capital, levels, alpha, bottom, offset, spacing, targetPrices, optimizationResult) {
            const epsilon = 0.1;
            const targetPricesInput = document.getElementById('targetPrices').value;

            // Generate price levels with progressive spacing
            const priceLevels = generateProgressiveLadder(startPrice, bottom, levels, spacing);

            // Calculate inverse weights
            const weights = priceLevels.map(p => 1 / Math.pow((p - bottom + epsilon), alpha));
            const sumWeights = weights.reduce((a, b) => a + b, 0);

            // Handle numerical overflow - if sumWeights is Infinity or 0, use equal weights
            if (!isFinite(sumWeights) || sumWeights === 0) {
                console.error('Invalid weight calculation - numerical overflow detected, using equal weights');
                const equalWeight = 1 / priceLevels.length;
                priceLevels.forEach((_, i) => {
                    weights[i] = equalWeight;
                });
            }

            const normWeights = weights.map(w => w / sumWeights);

            // Allocate capital
            const allocations = normWeights.map(w => roundFinancial(w * capital));
            const shares = allocations.map((a, i) => Math.floor(a / priceLevels[i]));

            // Calculate metrics
            const totalShares = shares.reduce((a, b) => a + b, 0);
            const totalAllocated = shares.reduce((sum, s, i) => sum + roundFinancial(s * priceLevels[i]), 0);
            const avgEntry = totalShares > 0 ? roundFinancial(totalAllocated / totalShares) : 0;

            const fib382 = roundFinancial(bottom + 0.382 * (startPrice - bottom));
            const fib618 = roundFinancial(bottom + 0.618 * (startPrice - bottom));

            // Update stats
            document.getElementById('avgEntry').textContent = totalShares > 0 ? formatCurrency(avgEntry) : '--';
            document.getElementById('totalShares').textContent = totalShares.toLocaleString();
            document.getElementById('fib382').textContent = formatCurrency(fib382);
            document.getElementById('fib618').textContent = formatCurrency(fib618);

            // Store for export
            currentLadderData = { symbol, priceLevels, shares, allocations, normWeights, targetPrices, optimizationResult };

            // Render
            renderChart(priceLevels, shares, startPrice, bottom, avgEntry, fib382, fib618, targetPrices);
            renderTable(priceLevels, shares, normWeights, totalAllocated, capital, targetPrices);

            // Update URL
            updateURLState({ symbol, startPrice: baseStartPrice, capital, levels, alpha, bottom, offset, spacing, targetPrices: targetPricesInput });
        }

        function renderChart(priceLevels, shares, startPrice, bottom, avgEntry, fib382, fib618, targetPrices) {
            const canvas = document.getElementById('chartCanvas');
            canvas.innerHTML = '';

            const priceRange = startPrice - bottom;
            const chartHeight = canvas.offsetHeight;

            if (priceRange <= 0 || chartHeight <= 0) return;

            const priceToY = (price) => {
                const ratio = (startPrice - price) / priceRange;
                return Math.max(0, Math.min(chartHeight, ratio * chartHeight));
            };

            const maxShares = Math.max(...shares);

            // Add target price indicators first (behind ladder lines)
            if (targetPrices && targetPrices.length > 0) {
                targetPrices.forEach((target, idx) => {
                    if (target >= bottom && target <= startPrice) {
                        const y = priceToY(target);
                        
                        const targetLine = document.createElement('div');
                        targetLine.style.position = 'absolute';
                        targetLine.style.left = '0';
                        targetLine.style.right = '0';
                        targetLine.style.top = `${y}px`;
                        targetLine.style.height = '3px';
                        targetLine.style.background = 'transparent';
                        targetLine.style.borderTop = '2px dotted var(--accent-warning)';
                        targetLine.style.opacity = '0.6';
                        targetLine.style.zIndex = '1';
                        
                        const targetLabel = document.createElement('div');
                        targetLabel.className = 'ladder-label';
                        targetLabel.textContent = `üéØ ${formatCurrency(target)}`;
                        targetLabel.style.top = `${y}px`;
                        targetLabel.style.left = '8px';
                        targetLabel.style.right = 'auto';
                        targetLabel.style.backgroundColor = 'rgba(255, 214, 10, 0.2)';
                        targetLabel.style.color = 'var(--accent-warning)';
                        targetLabel.style.fontWeight = '600';
                        targetLabel.style.border = '1px solid var(--accent-warning)';
                        targetLabel.style.zIndex = '2';
                        
                        canvas.appendChild(targetLine);
                        canvas.appendChild(targetLabel);
                    }
                });
            }

            // Add ladder lines
            priceLevels.forEach((price, i) => {
                const y = priceToY(price);
                const shareCount = shares[i];
                
                // Check if this level is EXACTLY aligned with a target price (within 0.1% tolerance)
                let isExactMatch = false;
                if (targetPrices) {
                    for (const target of targetPrices) {
                        const percentDiff = Math.abs(price - target) / target;
                        if (percentDiff < 0.001) { // 0.1% tolerance for exact match
                            isExactMatch = true;
                            break;
                        }
                    }
                }
                
                const line = document.createElement('div');
                line.className = 'ladder-line';
                line.style.top = `${y}px`;
                line.style.opacity = shareCount > 0 ? 0.6 + (shareCount / maxShares) * 0.4 : 0.2;
                line.style.zIndex = '3';
                
                // Highlight only exact matches
                if (isExactMatch) {
                    line.style.height = '4px';
                    line.style.background = 'var(--accent-warning)';
                    line.style.boxShadow = '0 0 12px var(--accent-warning)';
                    line.style.opacity = '1';
                }
                
                const label = document.createElement('div');
                label.className = 'ladder-label';
                label.textContent = `L${i + 1}: ${formatCurrency(price)} ‚Ä¢ ${shareCount} sh${isExactMatch ? ' üéØ' : ''}`;
                label.style.top = `${y}px`;
                label.style.zIndex = '4';
                
                if (isExactMatch) {
                    label.style.backgroundColor = 'var(--accent-warning)';
                    label.style.color = 'var(--bg-primary)';
                    label.style.fontWeight = '800';
                    label.style.border = '2px solid var(--accent-warning)';
                }
                
                canvas.appendChild(line);
                canvas.appendChild(label);
            });

            // Add average entry line
            if (avgEntry > 0) {
                const avgLine = document.createElement('div');
                avgLine.className = 'avg-line';
                avgLine.style.top = `${priceToY(avgEntry)}px`;
                avgLine.style.zIndex = '5';
                
                const avgLabel = document.createElement('div');
                avgLabel.className = 'ladder-label';
                avgLabel.style.backgroundColor = 'var(--accent-secondary)';
                avgLabel.style.color = 'var(--bg-primary)';
                avgLabel.style.fontWeight = '600';
                avgLabel.textContent = `AVG: ${formatCurrency(avgEntry)}`;
                avgLabel.style.top = `${priceToY(avgEntry)}px`;
                avgLabel.style.zIndex = '6';
                
                canvas.appendChild(avgLine);
                canvas.appendChild(avgLabel);
            }

            // Add Fibonacci lines
            const fib382Line = document.createElement('div');
            fib382Line.className = 'fib-line fib-382';
            fib382Line.style.top = `${priceToY(fib382)}px`;
            fib382Line.style.zIndex = '7';
            
            const fib382Label = document.createElement('div');
            fib382Label.className = 'ladder-label';
            fib382Label.textContent = `Fib 38.2%: ${formatCurrency(fib382)}`;
            fib382Label.style.top = `${priceToY(fib382)}px`;
            fib382Label.style.left = '8px';
            fib382Label.style.right = 'auto';
            fib382Label.style.zIndex = '8';
            
            const fib618Line = document.createElement('div');
            fib618Line.className = 'fib-line fib-618';
            fib618Line.style.top = `${priceToY(fib618)}px`;
            fib618Line.style.zIndex = '7';
            
            const fib618Label = document.createElement('div');
            fib618Label.className = 'ladder-label';
            fib618Label.textContent = `Fib 61.8%: ${formatCurrency(fib618)}`;
            fib618Label.style.top = `${priceToY(fib618)}px`;
            fib618Label.style.left = '8px';
            fib618Label.style.right = 'auto';
            fib618Label.style.zIndex = '8';
            
            canvas.appendChild(fib382Line);
            canvas.appendChild(fib382Label);
            canvas.appendChild(fib618Line);
            canvas.appendChild(fib618Label);
        }

        function renderTable(priceLevels, shares, normWeights, totalAllocated, capital, targetPrices) {
            const tbody = document.getElementById('ladderTableBody');
            tbody.innerHTML = '';

            const capitalUtilization = (totalAllocated / capital * 100);

            // Summary row
            const summaryRow = document.createElement('tr');
            summaryRow.style.background = 'var(--bg-secondary)';
            summaryRow.style.fontWeight = '600';
            summaryRow.style.borderBottom = '2px solid var(--accent-primary)';
            summaryRow.innerHTML = `
                <td colspan="3" style="color: var(--accent-primary);">TOTAL DEPLOYED</td>
                <td style="color: var(--accent-primary);">${formatCurrency(totalAllocated)}</td>
                <td style="color: var(--accent-secondary);">${capitalUtilization.toFixed(1)}%</td>
            `;
            tbody.appendChild(summaryRow);

            // Data rows
            priceLevels.forEach((price, i) => {
                const row = document.createElement('tr');
                const shareCount = shares[i];
                const allocation = roundFinancial(shareCount * price);
                const weight = normWeights[i] * 100;
                
                // Check if EXACTLY aligned with target (0.1% tolerance)
                let isExactMatch = false;
                if (targetPrices) {
                    for (const target of targetPrices) {
                        const percentDiff = Math.abs(price - target) / target;
                        if (percentDiff < 0.001) { // 0.1% tolerance
                            isExactMatch = true;
                            break;
                        }
                    }
                }

                row.innerHTML = `
                    <td class="highlight">${isExactMatch ? 'üéØ ' : ''}L${i + 1}</td>
                    <td style="${isExactMatch ? 'color: var(--accent-warning); font-weight: 800;' : ''}">${formatCurrency(price)}</td>
                    <td class="${shareCount > 0 ? 'highlight' : ''}">${shareCount.toLocaleString()}</td>
                    <td>${formatCurrency(allocation)}</td>
                    <td>${weight.toFixed(1)}%</td>
                `;
                tbody.appendChild(row);
            });

            document.getElementById('ladderTableContainer').style.display = 'block';
        }

        // Export functions
        function exportCSV() {
            if (!currentLadderData) return;
            const { symbol, priceLevels, shares, normWeights } = currentLadderData;
            
            let csv = 'Level,Price,Shares,Allocation,Weight %\n';
            priceLevels.forEach((price, i) => {
                const allocation = roundFinancial(shares[i] * price);
                const weight = (normWeights[i] * 100).toFixed(1);
                csv += `${i + 1},${price.toFixed(2)},${shares[i]},${allocation.toFixed(2)},${weight}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ladder_${symbol}_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function copyOrders() {
            if (!currentLadderData) return;
            const { symbol, priceLevels, shares } = currentLadderData;
            
            let orderText = `${symbol} Ladder Orders\n${'='.repeat(40)}\n\n`;
            priceLevels.forEach((price, i) => {
                if (shares[i] > 0) {
                    orderText += `BUY ${shares[i]} @ ${formatCurrency(price)}\n`;
                }
            });

            navigator.clipboard.writeText(orderText).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                btn.classList.add('success');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('success');
                }, 2000);
            });
        }

        function shareURL() {
            navigator.clipboard.writeText(window.location.href).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                btn.classList.add('success');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('success');
                }, 2000);
            });
        }

        // URL state management
        function updateURLState(params) {
            const url = new URL(window.location);
            Object.keys(params).forEach(key => {
                if (params[key] !== undefined && params[key] !== null && params[key] !== '') {
                    url.searchParams.set(key, params[key]);
                }
            });
            window.history.replaceState({}, '', url);
        }

        function loadURLState() {
            const url = new URL(window.location);
            let hasParams = false;

            // Helper function to validate and clamp numeric parameters
            function validateParam(value, min, max, defaultValue) {
                const parsed = parseFloat(value);
                if (isNaN(parsed)) return defaultValue;
                return Math.max(min, Math.min(max, parsed));
            }

            if (url.searchParams.has('symbol')) {
                const symbol = url.searchParams.get('symbol');
                // Sanitize symbol - only allow alphanumeric and common symbols
                const sanitized = symbol.replace(/[^A-Za-z0-9^.]/g, '').substring(0, 10);
                if (sanitized) {
                    document.getElementById('symbol').value = sanitized;
                    hasParams = true;
                }
            }
            if (url.searchParams.has('targetPrices')) {
                document.getElementById('targetPrices').value = url.searchParams.get('targetPrices');
                hasParams = true;
            }
            if (url.searchParams.has('startPrice')) {
                const startPrice = validateParam(url.searchParams.get('startPrice'), 0.01, 1000000, null);
                if (startPrice !== null) {
                    document.getElementById('startPrice').value = startPrice;
                    hasParams = true;
                }
            }
            if (url.searchParams.has('capital')) {
                const capital = validateParam(url.searchParams.get('capital'), 1, 1000000000, null);
                if (capital !== null) {
                    document.getElementById('capital').value = capital;
                    hasParams = true;
                }
            }
            if (url.searchParams.has('levels')) {
                // CRITICAL: Validate levels is between 5 and 30 to prevent division by zero
                const levels = validateParam(url.searchParams.get('levels'), 5, 30, 15);
                document.getElementById('levels').value = Math.round(levels);
                document.getElementById('levelsValue').textContent = Math.round(levels);
                hasParams = true;
            }
            if (url.searchParams.has('alpha')) {
                // CRITICAL: Validate alpha is within bounds to prevent numerical overflow
                const alpha = validateParam(url.searchParams.get('alpha'), -0.30, 3.0, 1.61);
                document.getElementById('alpha').value = alpha;
                document.getElementById('alphaValue').textContent = alpha.toFixed(2);
                hasParams = true;
            }
            if (url.searchParams.has('offset')) {
                const offset = validateParam(url.searchParams.get('offset'), -1.0, 1.0, 0);
                document.getElementById('offset').value = offset;
                document.getElementById('offsetValue').textContent = offset.toFixed(2);
                hasParams = true;
            }
            if (url.searchParams.has('spacing')) {
                const spacing = validateParam(url.searchParams.get('spacing'), 0.5, 2.0, 1.0);
                document.getElementById('spacing').value = spacing;
                document.getElementById('spacingValue').textContent = spacing.toFixed(2);
                hasParams = true;
            }
            if (url.searchParams.has('bottom')) {
                const bottom = validateParam(url.searchParams.get('bottom'), 0.01, 1000000, null);
                if (bottom !== null) {
                    document.getElementById('bottom').value = bottom;
                    hasParams = true;
                }
            }

            return hasParams;
        }

        // Initialize
        window.addEventListener('load', () => {
            loadURLState();
            // Initialize slider backgrounds with their types
            updateSliderBackground(document.getElementById('levels'), 'levels');
            updateSliderBackground(document.getElementById('alpha'), 'alpha');
            updateSliderBackground(document.getElementById('offset'), 'offset');
            updateSliderBackground(document.getElementById('spacing'), 'spacing');
            // Initial calculation with optimization if target prices exist
            setTimeout(() => calculateLadder(true), 100);
        });
    </script>
</body>
</html>
